"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sinclair";
exports.ids = ["vendor-chunks/@sinclair"];
exports.modules = {

/***/ "(rsc)/./node_modules/@sinclair/typebox/typebox.js":
/*!***************************************************!*\
  !*** ./node_modules/@sinclair/typebox/typebox.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for('TypeBox.Modifier');\nexports.Hint = Symbol.for('TypeBox.Hint');\nexports.Kind = Symbol.for('TypeBox.Kind');\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = '(true|false)';\nexports.PatternNumber = '(0|[1-9][0-9]*)';\nexports.PatternString = '(.*)';\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */\nvar TypeRegistry;\n(function (TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */\n    function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Returns true if this registry contains this kind */\n    function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */\n    function Set(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set;\n    /** Gets a custom validation function for a user defined type */\n    function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n/** A registry for user defined string formats */\nvar FormatRegistry;\n(function (FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */\n    function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */\n    function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Returns true if the user defined string format exists */\n    function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */\n    function Set(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set;\n    /** Gets a validation function for a user defined string format */\n    function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema) {\n        super('TypeGuard: Unknown type');\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */\nvar TypeGuard;\n(function (TypeGuard) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n    }\n    function IsArray(value) {\n        return typeof value === 'object' && value !== null && Array.isArray(value);\n    }\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (typeof value !== 'string')\n            return false;\n        for (let i = 0; i < value.length; i++) {\n            const code = value.charCodeAt(i);\n            if ((code >= 7 && code <= 13) || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsBigInt(value) {\n        return typeof value === 'bigint';\n    }\n    function IsString(value) {\n        return typeof value === 'string';\n    }\n    function IsNumber(value) {\n        return typeof value === 'number' && globalThis.Number.isFinite(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    function IsOptionalBigInt(value) {\n        return value === undefined || (value !== undefined && IsBigInt(value));\n    }\n    function IsOptionalNumber(value) {\n        return value === undefined || (value !== undefined && IsNumber(value));\n    }\n    function IsOptionalBoolean(value) {\n        return value === undefined || (value !== undefined && IsBoolean(value));\n    }\n    function IsOptionalString(value) {\n        return value === undefined || (value !== undefined && IsString(value));\n    }\n    function IsOptionalPattern(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value));\n    }\n    function IsOptionalFormat(value) {\n        return value === undefined || (value !== undefined && IsString(value) && IsControlCharacterFree(value));\n    }\n    function IsOptionalSchema(value) {\n        return value === undefined || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */\n    function TAny(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Any' && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */\n    function TArray(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Array' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.items) &&\n            IsOptionalNumber(schema.minItems) &&\n            IsOptionalNumber(schema.maxItems) &&\n            IsOptionalBoolean(schema.uniqueItems));\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TBigInt */\n    function TBigInt(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'BigInt' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'BigInt' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalBigInt(schema.multipleOf) &&\n            IsOptionalBigInt(schema.minimum) &&\n            IsOptionalBigInt(schema.maximum) &&\n            IsOptionalBigInt(schema.exclusiveMinimum) &&\n            IsOptionalBigInt(schema.exclusiveMaximum));\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */\n    function TBoolean(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Boolean' &&\n            schema.type === 'boolean' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */\n    function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Constructor' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Constructor' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */\n    function TDate(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Date' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Date' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minimumTimestamp) &&\n            IsOptionalNumber(schema.maximumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMinimumTimestamp) &&\n            IsOptionalNumber(schema.exclusiveMaximumTimestamp));\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */\n    function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Function' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Function' &&\n            IsOptionalString(schema.$id) &&\n            IsArray(schema.parameters) &&\n            TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters) {\n            if (!TSchema(parameter))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */\n    function TInteger(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Integer' &&\n            schema.type === 'integer' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */\n    function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Intersect' &&\n            IsArray(schema.allOf) &&\n            IsOptionalString(schema.type) &&\n            (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if ('type' in schema && schema.type !== 'object') {\n            return false;\n        }\n        for (const inner of schema.allOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TKind */\n    function TKind(schema) {\n        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === 'string'; // TS 4.1.5: any required for symbol indexer\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral<string> */\n    function TLiteralString(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'string';\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given schema is TLiteral<number> */\n    function TLiteralNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'number';\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given schema is TLiteral<boolean> */\n    function TLiteralBoolean(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Literal' && IsOptionalString(schema.$id) && typeof schema.const === 'boolean';\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given schema is TLiteral */\n    function TLiteral(schema) {\n        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */\n    function TNever(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Never' && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */\n    function TNot(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Not' &&\n            TSchema(schema.not));\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */\n    function TNull(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Null' &&\n            schema.type === 'null' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */\n    function TNumber(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Number' &&\n            schema.type === 'number' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.multipleOf) &&\n            IsOptionalNumber(schema.minimum) &&\n            IsOptionalNumber(schema.maximum) &&\n            IsOptionalNumber(schema.exclusiveMinimum) &&\n            IsOptionalNumber(schema.exclusiveMaximum));\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */\n    function TObject(schema) {\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Object' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsObject(schema.properties) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsOptionalNumber(schema.minProperties) &&\n            IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)) {\n            if (!IsControlCharacterFree(key))\n                return false;\n            if (!TSchema(value))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */\n    function TPromise(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Promise' &&\n            schema.type === 'object' &&\n            schema.instanceOf === 'Promise' &&\n            IsOptionalString(schema.$id) &&\n            TSchema(schema.item));\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */\n    function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Record' &&\n            schema.type === 'object' &&\n            IsOptionalString(schema.$id) &&\n            IsAdditionalProperties(schema.additionalProperties) &&\n            IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.keys(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */\n    function TRef(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Ref' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */\n    function TString(schema) {\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'String' &&\n            schema.type === 'string' &&\n            IsOptionalString(schema.$id) &&\n            IsOptionalNumber(schema.minLength) &&\n            IsOptionalNumber(schema.maxLength) &&\n            IsOptionalPattern(schema.pattern) &&\n            IsOptionalFormat(schema.format));\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */\n    function TSymbol(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Symbol' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Symbol' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */\n    function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'TemplateLiteral' &&\n            schema.type === 'string' &&\n            IsString(schema.pattern) &&\n            schema.pattern[0] === '^' &&\n            schema.pattern[schema.pattern.length - 1] === '$');\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */\n    function TThis(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'This' &&\n            IsOptionalString(schema.$id) &&\n            IsString(schema.$ref));\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */\n    function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Tuple' &&\n            schema.type === 'array' &&\n            IsOptionalString(schema.$id) &&\n            IsNumber(schema.minItems) &&\n            IsNumber(schema.maxItems) &&\n            schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n            return true;\n        }\n        if (!IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */\n    function TUndefined(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Undefined' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Undefined' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */\n    function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema) => TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUnion */\n    function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) &&\n            schema[exports.Kind] === 'Union' &&\n            IsArray(schema.anyOf) &&\n            IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf) {\n            if (!TSchema(inner))\n                return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUint8Array */\n    function TUint8Array(schema) {\n        return TKind(schema) && schema[exports.Kind] === 'Uint8Array' && schema.type === 'object' && IsOptionalString(schema.$id) && schema.instanceOf === 'Uint8Array' && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */\n    function TUnknown(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unknown' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */\n    function TUnsafe(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Unsafe');\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */\n    function TVoid(schema) {\n        // prettier-ignore\n        return (TKind(schema) &&\n            schema[exports.Kind] === 'Void' &&\n            schema.type === 'null' &&\n            schema.typeOf === 'Void' &&\n            IsOptionalString(schema.$id));\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the ReadonlyOptional modifier */\n    function TReadonlyOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'ReadonlyOptional';\n    }\n    TypeGuard.TReadonlyOptional = TReadonlyOptional;\n    /** Returns true if this schema has the Readonly modifier */\n    function TReadonly(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Readonly';\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */\n    function TOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === 'Optional';\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */\n    function TSchema(schema) {\n        return (typeof schema === 'object' &&\n            (TAny(schema) ||\n                TArray(schema) ||\n                TBoolean(schema) ||\n                TBigInt(schema) ||\n                TConstructor(schema) ||\n                TDate(schema) ||\n                TFunction(schema) ||\n                TInteger(schema) ||\n                TIntersect(schema) ||\n                TLiteral(schema) ||\n                TNever(schema) ||\n                TNot(schema) ||\n                TNull(schema) ||\n                TNumber(schema) ||\n                TObject(schema) ||\n                TPromise(schema) ||\n                TRecord(schema) ||\n                TRef(schema) ||\n                TString(schema) ||\n                TSymbol(schema) ||\n                TTemplateLiteral(schema) ||\n                TThis(schema) ||\n                TTuple(schema) ||\n                TUndefined(schema) ||\n                TUnion(schema) ||\n                TUint8Array(schema) ||\n                TUnknown(schema) ||\n                TUnsafe(schema) ||\n                TVoid(schema) ||\n                (TKind(schema) && TypeRegistry.Has(schema[exports.Kind]))));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */\nvar ExtendsUndefined;\n(function (ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === 'Undefined')\n            return true;\n        if (schema[exports.Kind] === 'Not') {\n            return !Check(schema.not);\n        }\n        if (schema[exports.Kind] === 'Intersect') {\n            const intersect = schema;\n            return intersect.allOf.every((schema) => Check(schema));\n        }\n        if (schema[exports.Kind] === 'Union') {\n            const union = schema;\n            return union.anyOf.some((schema) => Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function (TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function (TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function AnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Any(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function ArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function BigInt(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function BooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'boolean')\n            return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Boolean(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function Constructor(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function Date(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function Function(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TFunction(right))\n            return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length)\n            return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function IntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'number')\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Integer(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function IntersectRight(left, right) {\n        return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Intersect(left, right) {\n        return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function IsLiteralString(schema) {\n        return typeof schema.const === 'string';\n    }\n    function IsLiteralNumber(schema) {\n        return typeof schema.const === 'number';\n    }\n    function IsLiteralBoolean(schema) {\n        return typeof schema.const === 'boolean';\n    }\n    function Literal(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function NeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function Never(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapNot(schema) {\n        let [current, depth] = [schema, 0];\n        while (true) {\n            if (!TypeGuard.TNot(current))\n                break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function Not(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        if (TypeGuard.TNot(left))\n            return Visit(UnwrapNot(left), right);\n        if (TypeGuard.TNot(right))\n            return Visit(left, UnwrapNot(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for Not`);\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function Null(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function NumberRight(left, right) {\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Number(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return globalThis.Object.keys(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'description' in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && ((TypeGuard.TString(schema.properties.description.anyOf[0]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[1])) || (TypeGuard.TString(schema.properties.description.anyOf[1]) &&\n            TypeGuard.TUndefined(schema.properties.description.anyOf[0]))));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'length' in schema.properties && IntoBooleanResult(Visit(schema.properties['length'], length)) === TypeExtendsResult.True);\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || (IsObjectPropertyCount(schema, 1) && 'then' in schema.properties && IntoBooleanResult(Visit(schema.properties['then'], then)) === TypeExtendsResult.True);\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False)\n            return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right))\n            return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function ObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === 'Record' ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Object(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (!TypeGuard.TObject(right))\n            return TypeExtendsResult.False;\n        for (const key of globalThis.Object.keys(right.properties)) {\n            if (!(key in left.properties))\n                return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function Promise(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right))\n            return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties)\n            return exports.Type.String();\n        throw Error('TypeExtends: Cannot get record key');\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties)\n            return schema.patternProperties[exports.PatternStringExact];\n        throw Error('TypeExtends: Cannot get record value');\n    }\n    function RecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True)\n            return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key))\n            return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of globalThis.Object.keys(left.properties)) {\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Record(left, right) {\n        const Value = RecordValue(left);\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (!TypeGuard.TRecord(right))\n            return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function StringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === 'string')\n            return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function String(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function Symbol(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        if (TypeGuard.TTemplateLiteral(left))\n            return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right))\n            return Visit(left, TemplateLiteralResolver.Resolve(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function TupleRight(left, right) {\n        if (TypeGuard.TUnknown(left))\n            return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left))\n            return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left))\n            return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function IsArrayOfTuple(left, right) {\n        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);\n    }\n    function Tuple(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right))\n            return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right))\n            return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right))\n            return TypeExtendsResult.False;\n        if ((left.items === undefined && right.items !== undefined) || (left.items !== undefined && right.items === undefined))\n            return TypeExtendsResult.False;\n        if (left.items === undefined && right.items === undefined)\n            return TypeExtendsResult.True;\n        return left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function Uint8Array(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function Undefined(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TNever(right))\n            return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right))\n            return RecordRight(left, right);\n        if (TypeGuard.TVoid(right))\n            return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function UnionRight(left, right) {\n        return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Union(left, right) {\n        return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function UnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Unknown(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TString(right))\n            return StringRight(left, right);\n        if (TypeGuard.TNumber(right))\n            return NumberRight(left, right);\n        if (TypeGuard.TInteger(right))\n            return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right))\n            return BooleanRight(left, right);\n        if (TypeGuard.TArray(right))\n            return ArrayRight(left, right);\n        if (TypeGuard.TTuple(right))\n            return TupleRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left))\n            return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Void(left, right) {\n        if (TypeGuard.TIntersect(right))\n            return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right))\n            return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right))\n            return UnknownRight(left, right);\n        if (TypeGuard.TAny(right))\n            return AnyRight(left, right);\n        if (TypeGuard.TObject(right))\n            return ObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // Resolvable Types\n        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right))\n            return TemplateLiteral(left, right);\n        if (TypeGuard.TNot(left) || TypeGuard.TNot(right))\n            return Not(left, right);\n        // Standard Types\n        if (TypeGuard.TAny(left))\n            return Any(left, right);\n        if (TypeGuard.TArray(left))\n            return Array(left, right);\n        if (TypeGuard.TBigInt(left))\n            return BigInt(left, right);\n        if (TypeGuard.TBoolean(left))\n            return Boolean(left, right);\n        if (TypeGuard.TConstructor(left))\n            return Constructor(left, right);\n        if (TypeGuard.TDate(left))\n            return Date(left, right);\n        if (TypeGuard.TFunction(left))\n            return Function(left, right);\n        if (TypeGuard.TInteger(left))\n            return Integer(left, right);\n        if (TypeGuard.TIntersect(left))\n            return Intersect(left, right);\n        if (TypeGuard.TLiteral(left))\n            return Literal(left, right);\n        if (TypeGuard.TNever(left))\n            return Never(left, right);\n        if (TypeGuard.TNull(left))\n            return Null(left, right);\n        if (TypeGuard.TNumber(left))\n            return Number(left, right);\n        if (TypeGuard.TObject(left))\n            return Object(left, right);\n        if (TypeGuard.TRecord(left))\n            return Record(left, right);\n        if (TypeGuard.TString(left))\n            return String(left, right);\n        if (TypeGuard.TSymbol(left))\n            return Symbol(left, right);\n        if (TypeGuard.TTuple(left))\n            return Tuple(left, right);\n        if (TypeGuard.TPromise(left))\n            return Promise(left, right);\n        if (TypeGuard.TUint8Array(left))\n            return Uint8Array(left, right);\n        if (TypeGuard.TUndefined(left))\n            return Undefined(left, right);\n        if (TypeGuard.TUnion(left))\n            return Union(left, right);\n        if (TypeGuard.TUnknown(left))\n            return Unknown(left, right);\n        if (TypeGuard.TVoid(left))\n            return Void(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */\nvar TypeClone;\n(function (TypeClone) {\n    function IsObject(value) {\n        return typeof value === 'object' && value !== null;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function Array(value) {\n        return value.map((value) => Visit(value));\n    }\n    function Object(value) {\n        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key) => {\n            return { ...acc, [key]: Visit(value[key]) };\n        }, {});\n        return { ...clonedProperties, ...clonedSymbols };\n    }\n    function Visit(value) {\n        if (IsArray(value))\n            return Array(value);\n        if (IsObject(value))\n            return Object(value);\n        return value;\n    }\n    /** Clones a type. */\n    function Clone(schema, options) {\n        return { ...Visit(schema), ...options };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function (IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema) => {\n            const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema, {});\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema) => TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema) => TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        const optional = IsIntersectOptional(schema.allOf);\n        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        const optional = IsUnionOptional(schema.anyOf);\n        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        if (schema[exports.Kind] === 'Intersect')\n            return ResolveIntersect(schema);\n        if (schema[exports.Kind] === 'Union')\n            return ResolveUnion(schema);\n        return schema;\n    }\n    function Intersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema) => {\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === 'Never' ? acc : [...acc, indexed];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function Union(schema, key) {\n        const resolved = schema.anyOf.map((schema) => Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function Object(schema, key) {\n        const property = schema.properties[key];\n        return property === undefined ? exports.Type.Never() : exports.Type.Union([property]);\n    }\n    function Tuple(schema, key) {\n        const items = schema.items;\n        if (items === undefined)\n            return exports.Type.Never();\n        const element = items[key]; //\n        if (element === undefined)\n            return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        if (schema[exports.Kind] === 'Intersect')\n            return Intersect(schema, key);\n        if (schema[exports.Kind] === 'Union')\n            return Union(schema, key);\n        if (schema[exports.Kind] === 'Object')\n            return Object(schema, key);\n        if (schema[exports.Kind] === 'Tuple')\n            return Tuple(schema, key);\n        return exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key) => Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function (ObjectMap) {\n    function Intersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Union(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });\n    }\n    function Object(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === 'Intersect')\n            return Intersect(schema, callback);\n        if (schema[exports.Kind] === 'Union')\n            return Union(schema, callback);\n        if (schema[exports.Kind] === 'Object')\n            return Object(schema, callback);\n        return schema;\n    }\n    function Map(schema, callback, options) {\n        return { ...Visit(TypeClone.Clone(schema, {}), callback), ...options };\n    }\n    ObjectMap.Map = Map;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function (KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === '^' && key[key.length - 1] === '$' ? key.slice(1, key.length - 1) : key;\n    }\n    function Intersect(schema, options) {\n        return schema.allOf.reduce((acc, schema) => [...acc, ...Visit(schema, options)], []);\n    }\n    function Union(schema, options) {\n        const sets = schema.anyOf.map((inner) => Visit(inner, options));\n        return [...sets.reduce((set, outer) => outer.map((key) => (sets.every((inner) => inner.includes(key)) ? set.add(key) : set))[0], new Set())];\n    }\n    function Object(schema, options) {\n        return globalThis.Object.keys(schema.properties);\n    }\n    function Record(schema, options) {\n        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        if (TypeGuard.TIntersect(schema))\n            return Intersect(schema, options);\n        if (TypeGuard.TUnion(schema))\n            return Union(schema, options);\n        if (TypeGuard.TObject(schema))\n            return Object(schema, options);\n        if (TypeGuard.TRecord(schema))\n            return Record(schema, options);\n        return [];\n    }\n    /** Resolves an array of keys in this schema */\n    function ResolveKeys(schema, options) {\n        return [...new Set(Visit(schema, options))];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */\n    function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, { includePatterns: true });\n        const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);\n        return `^(${pattern.join('|')})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nvar KeyArrayResolver;\n(function (KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */\n    function Resolve(schema) {\n        if (globalThis.Array.isArray(schema))\n            return schema;\n        if (TypeGuard.TUnionLiteral(schema))\n            return schema.anyOf.map((schema) => schema.const.toString());\n        if (TypeGuard.TLiteral(schema))\n            return [schema.const];\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n            if (!TemplateLiteralFinite.Check(expression))\n                throw Error('KeyArrayResolver: Cannot resolve keys from infinite template expression');\n            return [...TemplateLiteralGenerator.Generate(expression)];\n        }\n        return [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function (UnionResolver) {\n    function* Union(union) {\n        for (const schema of union.anyOf) {\n            if (schema[exports.Kind] === 'Union') {\n                yield* Union(schema);\n            }\n            else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */\n    function Resolve(union) {\n        return exports.Type.Union([...Union(union)], { ...union });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function (TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n            return pattern;\n        }\n        else if (TypeGuard.TUnion(schema)) {\n            const tokens = schema.anyOf.map((schema) => Visit(schema, acc)).join('|');\n            return `(${tokens})`;\n        }\n        else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        }\n        else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        }\n        else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        }\n        else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        }\n        else if (TypeGuard.TNever(schema)) {\n            throw Error('TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever');\n        }\n        else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema) => Visit(schema, '')).join('')}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function (TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */\n    function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression))\n            return exports.Type.String();\n        const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function (TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, '(');\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, ')');\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, '|');\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))\n            return false;\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (count === 0 && index !== pattern.length - 1)\n                return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0)\n                return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [0, 0];\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index))\n                count += 1;\n            if (IsCloseParen(pattern, index))\n                count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0)\n            expressions.push(Parse(range));\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'or', expr: expressions };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index))\n                throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for (let scan = index; scan < value.length; scan++) {\n                if (IsOpenParen(value, scan))\n                    count += 1;\n                if (IsCloseParen(value, scan))\n                    count -= 1;\n                if (count === 0)\n                    return [index, scan];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for (let scan = index; scan < pattern.length; scan++) {\n                if (IsOpenParen(pattern, scan))\n                    return [index, scan];\n            }\n            return [index, pattern.length];\n        }\n        const expressions = [];\n        for (let index = 0; index < pattern.length; index++) {\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            }\n            else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0)\n                    expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0)\n            return { type: 'const', const: '' };\n        if (expressions.length === 1)\n            return expressions[0];\n        return { type: 'and', expr: expressions };\n    }\n    /** Parses a pattern and returns an expression tree */\n    function Parse(pattern) {\n        if (IsGroup(pattern))\n            return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern))\n            return Or(pattern);\n        if (IsPrecedenceAnd(pattern))\n            return And(pattern);\n        return { type: 'const', const: pattern };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */\n    function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function (TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === '0' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === '[1-9][0-9]*');\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return (expression.type === 'or' &&\n            expression.expr.length === 2 &&\n            expression.expr[0].type === 'const' &&\n            expression.expr[0].const === 'true' &&\n            expression.expr[1].type === 'const' &&\n            expression.expr[1].const === 'false');\n    }\n    function IsString(expression) {\n        return expression.type === 'const' && expression.const === '.*';\n    }\n    function Check(expression) {\n        if (IsBoolean(expression))\n            return true;\n        if (IsNumber(expression) || IsString(expression))\n            return false;\n        if (expression.type === 'and')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'or')\n            return expression.expr.every((expr) => Check(expr));\n        if (expression.type === 'const')\n            return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function (TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1)\n            return yield* buffer[0];\n        for (const left of buffer[0]) {\n            for (const right of Reduce(buffer.slice(1))) {\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)\n            yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === 'and')\n            return yield* And(expression);\n        if (expression.type === 'or')\n            return yield* Or(expression);\n        if (expression.type === 'const')\n            return yield* Const(expression);\n        throw Error('TemplateLiteralGenerator: Unknown expression');\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function (TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, '');\n        if (trim === 'boolean')\n            return yield exports.Type.Boolean();\n        if (trim === 'number')\n            return yield exports.Type.Number();\n        if (trim === 'bigint')\n            return yield exports.Type.BigInt();\n        if (trim === 'string')\n            return yield exports.Type.String();\n        const literals = trim.split('|').map((literal) => exports.Type.Literal(literal.trim()));\n        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== '{') {\n            const L = exports.Type.Literal('$');\n            const R = ParseLiteral(template.slice(1));\n            return yield* [L, ...R];\n        }\n        for (let i = 2; i < template.length; i++) {\n            if (template[i] === '}') {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [...L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for (let i = 0; i < template.length; i++) {\n            if (template[i] === '$') {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [L, ...R];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [...ParseLiteral(template_dsl)];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */\n    Create(schema) {\n        return schema;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */\n    Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Modifier]` Creates a Optional property */\n    Optional(schema) {\n        return { [exports.Modifier]: 'Optional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a ReadonlyOptional property */\n    ReadonlyOptional(schema) {\n        return { [exports.Modifier]: 'ReadonlyOptional', ...TypeClone.Clone(schema, {}) };\n    }\n    /** `[Modifier]` Creates a Readonly object or property */\n    Readonly(schema) {\n        return { [exports.Modifier]: 'Readonly', ...schema };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */\n    Any(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Any' });\n    }\n    /** `[Standard]` Creates an Array type */\n    Array(items, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Array', type: 'array', items: TypeClone.Clone(items, {}) });\n    }\n    /** `[Standard]` Creates a Boolean type */\n    Boolean(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Boolean', type: 'boolean' });\n    }\n    /** `[Standard]` Creates a Composite object type. */\n    Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });\n        const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Standard]` Creates a Enum type */\n    Enum(item, options = {}) {\n        // prettier-ignore\n        const values = globalThis.Object.keys(item).filter((key) => isNaN(key)).map((key) => item[key]);\n        const anyOf = values.map((value) => (typeof value === 'string' ? { [exports.Kind]: 'Literal', type: 'string', const: value } : { [exports.Kind]: 'Literal', type: 'number', const: value }));\n        return this.Create({ ...options, [exports.Kind]: 'Union', anyOf });\n    }\n    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */\n    Extends(left, right, trueType, falseType, options = {}) {\n        switch (TypeExtends.Extends(left, right)) {\n            case TypeExtendsResult.Union:\n                return this.Union([TypeClone.Clone(trueType, options), TypeClone.Clone(falseType, options)]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */\n    Exclude(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options));\n        }\n    }\n    /** `[Standard]` Extracts from the left type any type that is assignable to the right */\n    Extract(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left))\n            return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right))\n            return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner) => TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n            return (narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options));\n        }\n        else {\n            return (TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options));\n        }\n    }\n    /** `[Standard]` Returns indexed property types for the given keys */\n    Index(schema, unresolved, options = {}) {\n        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {\n            return TypeClone.Clone(schema.items, options);\n        }\n        else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const cloned = items.map((schema) => TypeClone.Clone(schema, {}));\n            return this.Union(cloned, options);\n        }\n        else {\n            const keys = KeyArrayResolver.Resolve(unresolved);\n            const clone = TypeClone.Clone(schema, {});\n            return IndexedAccessor.Resolve(clone, keys, options);\n        }\n    }\n    /** `[Standard]` Creates an Integer type */\n    Integer(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Integer', type: 'integer' });\n    }\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0)\n            return exports.Type.Never();\n        if (allOf.length === 1)\n            return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema) => TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema) => TypeClone.Clone(schema, {}));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {}) } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', type: 'object', allOf: cloned });\n        }\n        else {\n            return this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: 'Intersect', allOf: cloned });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */\n    KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact)\n                return this.Number(options);\n            if (pattern === exports.PatternStringExact)\n                return this.String(options);\n            throw Error('StandardTypeBuilder: Unable to resolve key type from Record key pattern');\n        }\n        else if (TypeGuard.TTuple(schema)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const literals = items.map((_, index) => exports.Type.Literal(index));\n            return this.Union(literals, options);\n        }\n        else if (TypeGuard.TArray(schema)) {\n            return this.Number(options);\n        }\n        else {\n            const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });\n            if (keys.length === 0)\n                return this.Never(options);\n            const literals = keys.map((key) => this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */\n    Literal(value, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Literal', const: value, type: typeof value });\n    }\n    /** `[Standard]` Creates a Never type */\n    Never(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Never', not: {} });\n    }\n    /** `[Standard]` Creates a Not type */\n    Not(not, options) {\n        return this.Create({ ...options, [exports.Kind]: 'Not', not });\n    }\n    /** `[Standard]` Creates a Null type */\n    Null(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Null', type: 'null' });\n    }\n    /** `[Standard]` Creates a Number type */\n    Number(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Number', type: 'number' });\n    }\n    /** `[Standard]` Creates an Object type */\n    Object(properties, options = {}) {\n        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Clone(options.additionalProperties, {}) } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(properties[key], {}) }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties, required: requiredKeys });\n        }\n        else {\n            return this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: 'Object', type: 'object', properties: clonedProperties });\n        }\n    }\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => !keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Optional */\n    Partial(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'ReadonlyOptional';\n                    break;\n                case 'Optional':\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n                default:\n                    schema[exports.Modifier] = 'Optional';\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            delete schema.required;\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            if (schema.required) {\n                schema.required = schema.required.filter((key) => keys.includes(key));\n                if (schema.required.length === 0)\n                    delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)) {\n                if (!keys.includes(key))\n                    delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */\n    Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression)\n                ? (this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key) => ({ ...acc, [key]: TypeClone.Clone(schema, {}) }), {}), options))\n                : this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [key.pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else if (TypeGuard.TUnion(key)) {\n            const union = UnionResolver.Resolve(key);\n            if (TypeGuard.TUnionLiteral(union)) {\n                const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Clone(schema, {}) }), {});\n                return this.Object(properties, { ...options, [exports.Hint]: 'Record' });\n            }\n            else\n                throw Error('TypeBuilder: Record key of type union contains non-literal types');\n        }\n        else if (TypeGuard.TLiteral(key)) {\n            if (typeof key.const === 'string' || typeof key.const === 'number') {\n                return this.Object({ [key.const]: TypeClone.Clone(schema, {}) }, options);\n            }\n            else\n                throw Error('TypeBuilder: Record key of type literal is not of type string or number');\n        }\n        else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            const pattern = exports.PatternNumberExact;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else if (TypeGuard.TString(key)) {\n            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n            return this.Create({ ...options, [exports.Kind]: 'Record', type: 'object', patternProperties: { [pattern]: TypeClone.Clone(schema, {}) } });\n        }\n        else {\n            throw Error(`StandardTypeBuilder: Record key is an invalid type`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */\n    Recursive(callback, options = {}) {\n        if (options.$id === undefined)\n            options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({ [exports.Kind]: 'This', $ref: `${options.$id}` });\n        thisType.$id = options.$id;\n        return this.Create({ ...options, [exports.Hint]: 'Recursive', ...thisType });\n    }\n    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */\n    Ref(schema, options = {}) {\n        if (schema.$id === undefined)\n            throw Error('StandardTypeBuilder.Ref: Target type must specify an $id');\n        return this.Create({ ...options, [exports.Kind]: 'Ref', $ref: schema.$id });\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Required */\n    Required(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch (schema[exports.Modifier]) {\n                case 'ReadonlyOptional':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Readonly':\n                    schema[exports.Modifier] = 'Readonly';\n                    break;\n                case 'Optional':\n                    delete schema[exports.Modifier];\n                    break;\n                default:\n                    delete schema[exports.Modifier];\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema) => {\n            schema.required = globalThis.Object.keys(schema.properties);\n            globalThis.Object.keys(schema.properties).forEach(key => Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */\n    Rest(schema) {\n        if (TypeGuard.TTuple(schema)) {\n            if (schema.items === undefined)\n                return [];\n            return schema.items.map((schema) => TypeClone.Clone(schema, {}));\n        }\n        else {\n            return [TypeClone.Clone(schema, {})];\n        }\n    }\n    /** `[Standard]` Creates a String type */\n    String(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string' });\n    }\n    /** `[Standard]` Creates a template literal type */\n    TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = (typeof unresolved === 'string')\n            ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved))\n            : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({ ...options, [exports.Kind]: 'TemplateLiteral', type: 'string', pattern });\n    }\n    /** `[Standard]` Creates a Tuple type */\n    Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [false, items.length, items.length];\n        const clonedItems = items.map((item) => TypeClone.Clone(item, {}));\n        // prettier-ignore\n        const schema = (items.length > 0 ?\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', items: clonedItems, additionalItems, minItems, maxItems } :\n            { ...options, [exports.Kind]: 'Tuple', type: 'array', minItems, maxItems });\n        return this.Create(schema);\n    }\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        }\n        else {\n            const anyOf = union;\n            if (anyOf.length === 0)\n                return this.Never(options);\n            if (anyOf.length === 1)\n                return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema) => TypeClone.Clone(schema, {}));\n            return this.Create({ ...options, [exports.Kind]: 'Union', anyOf: clonedAnyOf });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */\n    Unknown(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Unknown' });\n    }\n    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */\n    Unsafe(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || 'Unsafe' });\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a BigInt type */\n    BigInt(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'BigInt', type: 'null', typeOf: 'BigInt' });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */\n    ConstructorParameters(schema, options = {}) {\n        return this.Tuple([...schema.parameters], { ...options });\n    }\n    /** `[Extended]` Creates a Constructor type */\n    Constructor(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n        return this.Create({ ...options, [exports.Kind]: 'Constructor', type: 'object', instanceOf: 'Constructor', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Creates a Date type */\n    Date(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Date', type: 'object', instanceOf: 'Date' });\n    }\n    /** `[Extended]` Creates a Function type */\n    Function(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter) => TypeClone.Clone(parameter, {}));\n        return this.Create({ ...options, [exports.Kind]: 'Function', type: 'object', instanceOf: 'Function', parameters: clonedParameters, returns: clonedReturns });\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor */\n    InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */\n    Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, { ...options });\n    }\n    /** `[Extended]` Creates a Promise type */\n    Promise(item, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Promise', type: 'object', instanceOf: 'Promise', item: TypeClone.Clone(item, {}) });\n    }\n    /** `[Extended]` Creates a regular expression type */\n    RegEx(regex, options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'String', type: 'string', pattern: regex.source });\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function */\n    ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */\n    Symbol(options) {\n        return this.Create({ ...options, [exports.Kind]: 'Symbol', type: 'null', typeOf: 'Symbol' });\n    }\n    /** `[Extended]` Creates a Undefined type */\n    Undefined(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Undefined', type: 'null', typeOf: 'Undefined' });\n    }\n    /** `[Extended]` Creates a Uint8Array type */\n    Uint8Array(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Uint8Array', type: 'object', instanceOf: 'Uint8Array' });\n    }\n    /** `[Extended]` Creates a Void type */\n    Void(options = {}) {\n        return this.Create({ ...options, [exports.Kind]: 'Void', type: 'null', typeOf: 'Void' });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */\nexports.Type = new ExtendedTypeBuilder();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvdHlwZWJveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxtQkFBbUIsR0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGdCQUFnQjtBQUNyM0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsMkJBQTJCLE9BQU8sdUJBQXVCO0FBQ3pELDBCQUEwQixPQUFPLHNCQUFzQjtBQUN2RCwwQkFBMEIsT0FBTyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CLG9CQUFvQixvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLHdCQUF3Qix3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLHlCQUF5Qix5QkFBeUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELG1CQUFtQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsbUJBQW1CLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVMsSUFBSTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVMsSUFBSTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0MsNEJBQTRCO0FBQ2xGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQix1QkFBdUIsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLFdBQVc7QUFDeEc7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0IsaUJBQWlCLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFLDhDQUE4QyxtQkFBbUI7QUFDakUsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsbUJBQW1CLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLHdCQUF3Qix3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQixxQkFBcUIscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEVBQUUsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSxzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBLHNCQUFzQixJQUFJLEVBQUUsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSx1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxxQkFBcUI7QUFDekY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFrRDtBQUNyRTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkIsOEJBQThCLDhCQUE4QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEIsK0JBQStCLCtCQUErQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsNkJBQTZCLDZCQUE2QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLDZCQUE2Qiw2QkFBNkI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxFQUFFLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLGdDQUFnQyxnQ0FBZ0M7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQixnQ0FBZ0MsZ0NBQWdDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUE2RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUVBQXFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkIsb0ZBQW9GLEdBQUc7QUFDcEg7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkIsd0RBQXdEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCwwREFBMEQsd0JBQXdCO0FBQ2xGLHdEQUF3RCxxREFBcUQsS0FBSztBQUNsSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJFQUEyRSwwREFBMEQsSUFBSSx5REFBeUQ7QUFDbE0sNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNkJBQTZCLHdEQUF3RDtBQUNyRjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLGlHQUFpRyx3RUFBd0UsSUFBSTtBQUM3SztBQUNBLGlDQUFpQyx3R0FBd0c7QUFDekk7QUFDQTtBQUNBLGlDQUFpQyx3RkFBd0Y7QUFDekg7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0JBQXdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDZCQUE2Qix5RUFBeUU7QUFDdEc7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkIsOENBQThDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7QUFDckU7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw2QkFBNkIsa0RBQWtEO0FBQy9FO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkJBQTZCLHNEQUFzRDtBQUNuRjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixzRUFBc0UsSUFBSTtBQUN6SyxzRUFBc0Usa0RBQWtELEdBQUcsS0FBSztBQUNoSTtBQUNBLGlDQUFpQywySUFBMkk7QUFDNUs7QUFDQTtBQUNBLGlDQUFpQyxtSEFBbUg7QUFDcEo7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcseUNBQXlDLEdBQUcsS0FBSztBQUMzSixnQ0FBZ0MsMkVBQTJFLHlDQUF5QyxLQUFLO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLG1EQUFtRCxHQUFHLEtBQUs7QUFDdEksaURBQWlELHNDQUFzQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUNBQXVDLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJFQUEyRSxxQ0FBcUMsS0FBSztBQUN0SjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkVBQTJFLHFDQUFxQyxLQUFLO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLDhCQUE4QixjQUFjO0FBQzVDLG9DQUFvQyxpQ0FBaUMsWUFBWSxHQUFHO0FBQ3BGO0FBQ0EsNkJBQTZCLHNEQUFzRDtBQUNuRjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkIscURBQXFEO0FBQ2xGO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkJBQTZCLHNEQUFzRDtBQUNuRjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdFQUF3RTtBQUNyRztBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxjQUFjLDhHQUE4RztBQUM1SCxjQUFjLHdFQUF3RTtBQUN0RjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRixpQ0FBaUMseURBQXlEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkJBQTZCLCtEQUErRDtBQUM1RjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkJBQTZCLHNFQUFzRTtBQUNuRztBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCw0RkFBNEY7QUFDNUYsNkJBQTZCLDRJQUE0STtBQUN6SztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDZCQUE2Qix3RUFBd0U7QUFDckc7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pELDRGQUE0RjtBQUM1Riw2QkFBNkIsc0lBQXNJO0FBQ25LO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNkJBQTZCLDRHQUE0RyxHQUFHO0FBQzVJO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsNkJBQTZCLDZFQUE2RTtBQUMxRztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNFQUFzRTtBQUNuRztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2Qiw0RUFBNEU7QUFDekc7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw2QkFBNkIsb0ZBQW9GO0FBQ2pIO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNkJBQTZCLGtFQUFrRTtBQUMvRjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbnZlcnNlcy1haS8uL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC90eXBlYm94LmpzPzBmNDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94XG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAyMyBIYXlkbiBQYXRlcnNvbiAoc2luY2xhaXIpIDxoYXlkbi5kZXZlbG9wZXJAZ21haWwuY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGUgPSBleHBvcnRzLlN0YW5kYXJkVHlwZSA9IGV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IGV4cG9ydHMuU3RhbmRhcmRUeXBlQnVpbGRlciA9IGV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gZXhwb3J0cy5VbmlvblJlc29sdmVyID0gZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gZXhwb3J0cy5LZXlSZXNvbHZlciA9IGV4cG9ydHMuT2JqZWN0TWFwID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBleHBvcnRzLlR5cGVDbG9uZSA9IGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gZXhwb3J0cy5UeXBlR3VhcmQgPSBleHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9IGV4cG9ydHMuS2luZCA9IGV4cG9ydHMuSGludCA9IGV4cG9ydHMuTW9kaWZpZXIgPSB2b2lkIDA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ltYm9sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuTW9kaWZpZXIgPSBTeW1ib2wuZm9yKCdUeXBlQm94Lk1vZGlmaWVyJyk7XG5leHBvcnRzLkhpbnQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LkhpbnQnKTtcbmV4cG9ydHMuS2luZCA9IFN5bWJvbC5mb3IoJ1R5cGVCb3guS2luZCcpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhdHRlcm5zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9ICcodHJ1ZXxmYWxzZSknO1xuZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gJygwfFsxLTldWzAtOV0qKSc7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmcgPSAnKC4qKSc7XG5leHBvcnRzLlBhdHRlcm5Cb29sZWFuRXhhY3QgPSBgXiR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn0kYDtcbmV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybk51bWJlcn0kYDtcbmV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVyblN0cmluZ30kYDtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbnZhciBUeXBlUmVnaXN0cnk7XG4oZnVuY3Rpb24gKFR5cGVSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCB0eXBlcyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5DbGVhciA9IENsZWFyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWdpc3RyeSBjb250YWlucyB0aGlzIGtpbmQgKi9cbiAgICBmdW5jdGlvbiBIYXMoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBTZXQoa2luZCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGtpbmQsIGZ1bmMpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBHZXQoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmdldChraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKFR5cGVSZWdpc3RyeSB8fCAoZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBUeXBlUmVnaXN0cnkgPSB7fSkpO1xuLyoqIEEgcmVnaXN0cnkgZm9yIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xudmFyIEZvcm1hdFJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChGb3JtYXRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuRW50cmllcyA9IEVudHJpZXM7XG4gICAgLyoqIENsZWFycyBhbGwgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXRzICovXG4gICAgZnVuY3Rpb24gQ2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCBleGlzdHMgKi9cbiAgICBmdW5jdGlvbiBIYXMoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBTZXQoZm9ybWF0LCBmdW5jKSB7XG4gICAgICAgIG1hcC5zZXQoZm9ybWF0LCBmdW5jKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCAqL1xuICAgIGZ1bmN0aW9uIEdldChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoZm9ybWF0KTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuR2V0ID0gR2V0O1xufSkoRm9ybWF0UmVnaXN0cnkgfHwgKGV4cG9ydHMuRm9ybWF0UmVnaXN0cnkgPSBGb3JtYXRSZWdpc3RyeSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUd1YXJkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVHdWFyZDogVW5rbm93biB0eXBlJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciA9IFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3I7XG4vKiogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHRlc3QgaWYgSmF2YVNjcmlwdCB2YWx1ZXMgYXJlIFR5cGVCb3ggdHlwZXMgKi9cbnZhciBUeXBlR3VhcmQ7XG4oZnVuY3Rpb24gKFR5cGVHdWFyZCkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA+PSA3ICYmIGNvZGUgPD0gMTMpIHx8IGNvZGUgPT09IDI3IHx8IGNvZGUgPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBZGRpdGlvbmFsUHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPcHRpb25hbEJvb2xlYW4odmFsdWUpIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEJpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0JpZ0ludCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzQm9vbGVhbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSAmJiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSAmJiBJc1BhdHRlcm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU2NoZW1hKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEFueSAqL1xuICAgIGZ1bmN0aW9uIFRBbnkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQW55JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFueSA9IFRBbnk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FycmF5JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCb29sZWFuKHNjaGVtYS51bmlxdWVJdGVtcykpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFycmF5ID0gVEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQmlnSW50ICovXG4gICAgZnVuY3Rpb24gVEJpZ0ludChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCaWdJbnQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCaWdJbnQgPSBUQmlnSW50O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQm9vbGVhbiAqL1xuICAgIGZ1bmN0aW9uIFRCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Jvb2xlYW4nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCb29sZWFuID0gVEJvb2xlYW47XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRDb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRDb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRDb25zdHJ1Y3RvciA9IFRDb25zdHJ1Y3RvcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVERhdGUgKi9cbiAgICBmdW5jdGlvbiBURGF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRGF0ZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXApKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlREYXRlID0gVERhdGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRGdW5jdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFRGdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRGdW5jdGlvbiA9IFRGdW5jdGlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVnZXIgKi9cbiAgICBmdW5jdGlvbiBUSW50ZWdlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVnZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heGltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVnZXIgPSBUSW50ZWdlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVyc2VjdCAqL1xuICAgIGZ1bmN0aW9uIFRJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcgJiZcbiAgICAgICAgICAgIElzQXJyYXkoc2NoZW1hLmFsbE9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEudHlwZSkgJiZcbiAgICAgICAgICAgIChJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBJc09wdGlvbmFsU2NoZW1hKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3R5cGUnIGluIHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5USW50ZXJzZWN0ID0gVEludGVyc2VjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEtpbmQgKi9cbiAgICBmdW5jdGlvbiBUS2luZChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0KHNjaGVtYSkgJiYgZXhwb3J0cy5LaW5kIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdzdHJpbmcnOyAvLyBUUyA0LjEuNTogYW55IHJlcXVpcmVkIGZvciBzeW1ib2wgaW5kZXhlclxuICAgIH1cbiAgICBUeXBlR3VhcmQuVEtpbmQgPSBUS2luZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8c3RyaW5nPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbFN0cmluZyA9IFRMaXRlcmFsU3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxudW1iZXI+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTGl0ZXJhbCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsTnVtYmVyID0gVExpdGVyYWxOdW1iZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPGJvb2xlYW4+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxCb29sZWFuID0gVExpdGVyYWxCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbCAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpIHx8IFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWwgPSBUTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5ldmVyICovXG4gICAgZnVuY3Rpb24gVE5ldmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyAmJiBJc09iamVjdChzY2hlbWEubm90KSAmJiBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROZXZlciA9IFROZXZlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5vdCAqL1xuICAgIGZ1bmN0aW9uIFROb3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90JyAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEubm90KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTm90ID0gVE5vdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bGwgKi9cbiAgICBmdW5jdGlvbiBUTnVsbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVsbCA9IFROdWxsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTnVtYmVyICovXG4gICAgZnVuY3Rpb24gVE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROdW1iZXIgPSBUTnVtYmVyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUT2JqZWN0ICovXG4gICAgZnVuY3Rpb24gVE9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4UHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ29udHJvbENoYXJhY3RlckZyZWUoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPYmplY3QgPSBUT2JqZWN0O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUHJvbWlzZSAqL1xuICAgIGZ1bmN0aW9uIFRQcm9taXNlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnUHJvbWlzZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRQcm9taXNlID0gVFByb21pc2U7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWNvcmQgKi9cbiAgICBmdW5jdGlvbiBUUmVjb3JkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWNvcmQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPYmplY3Qoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1BhdHRlcm4oa2V5c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVRTY2hlbWEoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleXNbMF1dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlY29yZCA9IFRSZWNvcmQ7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWYgKi9cbiAgICBmdW5jdGlvbiBUUmVmKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1JlZicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS4kcmVmKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVmID0gVFJlZjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN0cmluZyAqL1xuICAgIGZ1bmN0aW9uIFRTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdTdHJpbmcnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxQYXR0ZXJuKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEZvcm1hdChzY2hlbWEuZm9ybWF0KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU3RyaW5nID0gVFN0cmluZztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN5bWJvbCAqL1xuICAgIGZ1bmN0aW9uIFRTeW1ib2woc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3ltYm9sJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGVPZiA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN5bWJvbCA9IFRTeW1ib2w7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUZW1wbGF0ZUxpdGVyYWwgKi9cbiAgICBmdW5jdGlvbiBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RlbXBsYXRlTGl0ZXJhbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLnBhdHRlcm4pICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVyblswXSA9PT0gJ14nICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVybltzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJyQnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwgPSBUVGVtcGxhdGVMaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGhpcyAqL1xuICAgIGZ1bmN0aW9uIFRUaGlzKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RoaXMnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFRoaXMgPSBUVGhpcztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFR1cGxlICovXG4gICAgZnVuY3Rpb24gVFR1cGxlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUdXBsZScgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmXG4gICAgICAgICAgICBzY2hlbWEubWluSXRlbXMgPT09IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgJiYgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5taW5JdGVtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVHVwbGUgPSBUVHVwbGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmRlZmluZWQgKi9cbiAgICBmdW5jdGlvbiBUVW5kZWZpbmVkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmRlZmluZWQgPSBUVW5kZWZpbmVkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb248TGl0ZXJhbDxzdHJpbmcgfCBudW1iZXI+W10+ICovXG4gICAgZnVuY3Rpb24gVFVuaW9uTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRVbmlvbihzY2hlbWEpICYmIHNjaGVtYS5hbnlPZi5ldmVyeSgoc2NoZW1hKSA9PiBUTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHx8IFRMaXRlcmFsTnVtYmVyKHNjaGVtYSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCA9IFRVbmlvbkxpdGVyYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmlvbiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5hbnlPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uID0gVFVuaW9uO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVWludDhBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRVaW50OEFycmF5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VpbnQ4QXJyYXknICYmIHNjaGVtYS50eXBlID09PSAnb2JqZWN0JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnVWludDhBcnJheScgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluQnl0ZUxlbmd0aCkgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVWludDhBcnJheSA9IFRVaW50OEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5rbm93biAqL1xuICAgIGZ1bmN0aW9uIFRVbmtub3duKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vua25vd24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmtub3duID0gVFVua25vd247XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIGEgcmF3IFRVbnNhZmUgKi9cbiAgICBmdW5jdGlvbiBUVW5zYWZlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vuc2FmZScpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuc2FmZSA9IFRVbnNhZmU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRWb2lkICovXG4gICAgZnVuY3Rpb24gVFZvaWQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdWb2lkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVm9pZCA9IFRWb2lkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzY2hlbWEgaGFzIHRoZSBSZWFkb25seU9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5T3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlYWRvbmx5T3B0aW9uYWwgPSBUUmVhZG9ubHlPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHkgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUUmVhZG9ubHkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5JztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seSA9IFRSZWFkb25seTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgT3B0aW9uYWwgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ09wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPcHRpb25hbCA9IFRPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFRTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIChUQW55KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRCb29sZWFuKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQmlnSW50KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQ29uc3RydWN0b3Ioc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFREYXRlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURnVuY3Rpb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRJbnRlZ2VyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZXJzZWN0KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTGl0ZXJhbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5ldmVyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTm90KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTnVsbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bWJlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE9iamVjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFByb21pc2Uoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWNvcmQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWYoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTdHJpbmcoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTeW1ib2woc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUaGlzKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVHVwbGUoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmRlZmluZWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmlvbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVpbnQ4QXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmtub3duKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5zYWZlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVm9pZChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgKFRLaW5kKHNjaGVtYSkgJiYgVHlwZVJlZ2lzdHJ5LkhhcyhzY2hlbWFbZXhwb3J0cy5LaW5kXSkpKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU2NoZW1hID0gVFNjaGVtYTtcbn0pKFR5cGVHdWFyZCB8fCAoZXhwb3J0cy5UeXBlR3VhcmQgPSBUeXBlR3VhcmQgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZHNVbmRlZmluZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogRmFzdCB1bmRlZmluZWQgY2hlY2sgdXNlZCBmb3IgcHJvcGVydGllcyBvZiB0eXBlIHVuZGVmaW5lZCAqL1xudmFyIEV4dGVuZHNVbmRlZmluZWQ7XG4oZnVuY3Rpb24gKEV4dGVuZHNVbmRlZmluZWQpIHtcbiAgICBmdW5jdGlvbiBDaGVjayhzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gIUNoZWNrKHNjaGVtYS5ub3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3QuYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gQ2hlY2soc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiB1bmlvbi5hbnlPZi5zb21lKChzY2hlbWEpID0+IENoZWNrKHNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgRXh0ZW5kc1VuZGVmaW5lZC5DaGVjayA9IENoZWNrO1xufSkoRXh0ZW5kc1VuZGVmaW5lZCB8fCAoZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gRXh0ZW5kc1VuZGVmaW5lZCA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUV4dGVuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVHlwZUV4dGVuZHNSZXN1bHQ7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzUmVzdWx0KSB7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJVbmlvblwiXSA9IDBdID0gXCJVbmlvblwiO1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiVHJ1ZVwiXSA9IDFdID0gXCJUcnVlXCI7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJGYWxzZVwiXSA9IDJdID0gXCJGYWxzZVwiO1xufSkoVHlwZUV4dGVuZHNSZXN1bHQgfHwgKGV4cG9ydHMuVHlwZUV4dGVuZHNSZXN1bHQgPSBUeXBlRXh0ZW5kc1Jlc3VsdCA9IHt9KSk7XG52YXIgVHlwZUV4dGVuZHM7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRvQm9vbGVhblJlc3VsdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50b0Jvb2xlYW5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFueVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQW55UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFueShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpICYmIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRBbnkoc2NoZW1hKSB8fCBUeXBlR3VhcmQuVFVua25vd24oc2NoZW1hKSkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQXJyYXlSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0Lml0ZW1zLCByaWdodC5pdGVtcykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpZ0ludFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQmlnSW50KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQmlnSW50KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb29sZWFuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJvb2xlYW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UQ29uc3RydWN0b3IocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5wYXJhbWV0ZXJzLmxlbmd0aCA+IHJpZ2h0LnBhcmFtZXRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoIWxlZnQucGFyYW1ldGVycy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQocmlnaHQucGFyYW1ldGVyc1tpbmRleF0sIHNjaGVtYSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LnJldHVybnMsIHJpZ2h0LnJldHVybnMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBEYXRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVERhdGUocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBGdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRGdW5jdGlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0LnBhcmFtZXRlcnMubGVuZ3RoID4gcmlnaHQucGFyYW1ldGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICghbGVmdC5wYXJhbWV0ZXJzLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChyaWdodC5wYXJhbWV0ZXJzW2luZGV4XSwgc2NoZW1hKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQucmV0dXJucywgcmlnaHQucmV0dXJucykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludGVnZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgfHwgVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlZ2VyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkgfHwgVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVyc2VjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFsbE9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KGxlZnQsIHNjaGVtYSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuYWxsT2Yuc29tZSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRMaXRlcmFsKHJpZ2h0KSAmJiByaWdodC5jb25zdCA9PT0gbGVmdC5jb25zdCA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOZXZlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTmV2ZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5ldmVyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE5vdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW53cmFwTm90KHNjaGVtYSkge1xuICAgICAgICBsZXQgW2N1cnJlbnQsIGRlcHRoXSA9IFtzY2hlbWEsIDBdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFUeXBlR3VhcmQuVE5vdChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5vdDtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoICUgMiA9PT0gMCA/IGN1cnJlbnQgOiBleHBvcnRzLlR5cGUuVW5rbm93bigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBuZWdhdGVkIHR5cGVzLCBhbmQgYXR0ZW1wdHMgdG8gY29ycmVjdGx5IGNoZWNrIHRoZSBuZWdhdGVkXG4gICAgICAgIC8vIHR5cGUgYXQgcnVudGltZSB3b3VsZCBwdXQgVHlwZUJveCBhdCBvZGRzIHdpdGggVHlwZVNjcmlwdHMgYWJpbGl0eSB0byBzdGF0aWNhbGx5IGluZmVyXG4gICAgICAgIC8vIHRoZSB0eXBlLiBJbnN0ZWFkIHdlIHVud3JhcCB0byBlaXRoZXIgdW5rbm93biBvciBUIGFuZCBjb250aW51ZSBldmFsdWF0aW5nLlxuICAgICAgICBpZiAoVHlwZUd1YXJkLlROb3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQoVW53cmFwTm90KGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5vdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVW53cmFwTm90KHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIE5vdGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE51bGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bGwobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdWxsKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOdW1iZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsTnVtYmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSB8fCBUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE51bWJlcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBPYmplY3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPT09IGNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN0cmluZ0xpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN5bWJvbExpa2Uoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdkZXNjcmlwdGlvbicgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbikgJiYgc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2YubGVuZ3RoID09PSAyICYmICgoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMF0pICYmXG4gICAgICAgICAgICBUeXBlR3VhcmQuVFVuZGVmaW5lZChzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkpIHx8IChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkgJiZcbiAgICAgICAgICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzBdKSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3ROdW1iZXJMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Qm9vbGVhbkxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RCaWdJbnRMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RGF0ZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RVaW50OEFycmF5TGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RnVuY3Rpb25MaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvbWlzZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHRoZW4gPSBleHBvcnRzLlR5cGUuRnVuY3Rpb24oW2V4cG9ydHMuVHlwZS5BbnkoKV0sIGV4cG9ydHMuVHlwZS5BbnkoKSk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ3RoZW4nIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWyd0aGVuJ10sIHRoZW4pKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvcGVydHlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFByb3BlcnR5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChWaXNpdChsZWZ0LCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPcHRpb25hbChsZWZ0KSAmJiAhVHlwZUd1YXJkLlRPcHRpb25hbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3RSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxOdW1iZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQmlnSW50KGxlZnQpICYmIElzT2JqZWN0QmlnSW50TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSAmJiBJc09iamVjdFVpbnQ4QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpICYmIElzT2JqZWN0RGF0ZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVENvbnN0cnVjdG9yKGxlZnQpICYmIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSAmJiBJc09iamVjdEZ1bmN0aW9uTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpICYmIFR5cGVHdWFyZC5UU3RyaW5nKFJlY29yZEtleShsZWZ0KSkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZXhwcmVzc2luZyBhIFJlY29yZCB3aXRoIGxpdGVyYWwga2V5IHZhbHVlcywgdGhlIFJlY29yZCBpcyBjb252ZXJ0ZWQgaW50byBhIE9iamVjdCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgSGludCBhc3NpZ25lZCBhcyBgUmVjb3JkYC4gVGhpcyBpcyB1c2VkIHRvIGludmVydCB0aGUgZXh0ZW5kcyBsb2dpYy5cbiAgICAgICAgICAgIHJldHVybiByaWdodFtleHBvcnRzLkhpbnRdID09PSAnUmVjb3JkJyA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoUmVjb3JkS2V5KGxlZnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChyaWdodCwgMCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhyaWdodC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGxlZnQucHJvcGVydGllcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgaWYgKFByb3BlcnR5KGxlZnQucHJvcGVydGllc1trZXldLCByaWdodC5wcm9wZXJ0aWVzW2tleV0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9taXNlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBQcm9taXNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0UHJvbWlzZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRQcm9taXNlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQuaXRlbSwgcmlnaHQuaXRlbSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlY29yZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUmVjb3JkS2V5KHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuU3RyaW5nKCk7XG4gICAgICAgIHRocm93IEVycm9yKCdUeXBlRXh0ZW5kczogQ2Fubm90IGdldCByZWNvcmQga2V5Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZFZhbHVlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1tleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdF07XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2V4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0XTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVFeHRlbmRzOiBDYW5ub3QgZ2V0IHJlY29yZCB2YWx1ZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBLZXkgPSBSZWNvcmRLZXkocmlnaHQpO1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxTdHJpbmcobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LCBWYWx1ZSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChsZWZ0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhsZWZ0LnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFByb3BlcnR5KFZhbHVlLCBsZWZ0LnByb3BlcnRpZXNba2V5XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKGxlZnQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gVmlzaXQoVmFsdWUsIFJlY29yZFZhbHVlKHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0cmluZyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3ltYm9sXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTeW1ib2wobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTeW1ib2wocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRlbXBsYXRlTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFRlbXBsYXRlTGl0ZXJhbCB0eXBlcyBhcmUgcmVzb2x2ZWQgdG8gZWl0aGVyIHVuaW9ucyBmb3IgZmluaXRlIGV4cHJlc3Npb25zIG9yIHN0cmluZ1xuICAgICAgICAvLyBmb3IgaW5maW5pdGUgZXhwcmVzc2lvbnMuIEhlcmUgd2UgY2FsbCB0byBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB0byByZXNvbHZlIGZvclxuICAgICAgICAvLyBlaXRoZXIgdHlwZSBhbmQgY29udGludWUgZXZhbHVhdGluZy5cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIFRlbXBsYXRlTGl0ZXJhbGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFR1cGxlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBUdXBsZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5T2ZUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRBcnJheShyaWdodCkgJiYgbGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodC5pdGVtcykgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpICYmIElzQXJyYXlPZlR1cGxlKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UVHVwbGUocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoKGxlZnQuaXRlbXMgPT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB8fCAobGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQuaXRlbXNbaW5kZXhdKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVWludDhBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVWludDhBcnJheShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVaW50OEFycmF5KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmRlZmluZWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuZGVmaW5lZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFZvaWQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5pb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVmlzaXQobGVmdCwgc2NoZW1hKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmFueU9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmtub3duXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGVSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBWb2lkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBWb2lkUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFZvaWQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChsZWZ0LCByaWdodCkge1xuICAgICAgICAvLyBSZXNvbHZhYmxlIFR5cGVzXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSB8fCBUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTm90KGxlZnQpIHx8IFR5cGVHdWFyZC5UTm90KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOb3QobGVmdCwgcmlnaHQpO1xuICAgICAgICAvLyBTdGFuZGFyZCBUeXBlc1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQW55KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCaWdJbnQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQ29uc3RydWN0b3IobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIERhdGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIExpdGVyYWwobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bGwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTnVsbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVHVwbGUobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRQcm9taXNlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5kZWZpbmVkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRWb2lkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aHJvdyBFcnJvcihgVHlwZUV4dGVuZHM6IFVua25vd24gbGVmdCB0eXBlIG9wZXJhbmQgJyR7bGVmdFtleHBvcnRzLktpbmRdfSdgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0ZW5kcyhsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBUeXBlRXh0ZW5kcy5FeHRlbmRzID0gRXh0ZW5kcztcbn0pKFR5cGVFeHRlbmRzIHx8IChleHBvcnRzLlR5cGVFeHRlbmRzID0gVHlwZUV4dGVuZHMgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVDbG9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBTcGVjaWFsaXplZCBDbG9uZSBmb3IgVHlwZXMgKi9cbnZhciBUeXBlQ2xvbmU7XG4oZnVuY3Rpb24gKFR5cGVDbG9uZSkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2YWx1ZSkgPT4gVmlzaXQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFByb3BlcnRpZXMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBWaXNpdCh2YWx1ZVtrZXldKSB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFN5bWJvbHMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IFZpc2l0KHZhbHVlW2tleV0pIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2xvbmVkUHJvcGVydGllcywgLi4uY2xvbmVkU3ltYm9scyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdCh2YWx1ZSkge1xuICAgICAgICBpZiAoSXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoSXNPYmplY3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIENsb25lcyBhIHR5cGUuICovXG4gICAgZnVuY3Rpb24gQ2xvbmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KHNjaGVtYSksIC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgVHlwZUNsb25lLkNsb25lID0gQ2xvbmU7XG59KShUeXBlQ2xvbmUgfHwgKGV4cG9ydHMuVHlwZUNsb25lID0gVHlwZUNsb25lID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbmRleGVkQWNjZXNzb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSW5kZXhlZEFjY2Vzc29yO1xuKGZ1bmN0aW9uIChJbmRleGVkQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBPcHRpb25hbFVud3JhcChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXAoKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBbZXhwb3J0cy5Nb2RpZmllcl06IF8sIC4uLmNsb25lIH0gPSBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0ludGVyc2VjdE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmV2ZXJ5KChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVW5pb25PcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zb21lKChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gSXNJbnRlcnNlY3RPcHRpb25hbChzY2hlbWEuYWxsT2YpO1xuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBleHBvcnRzLlR5cGUuT3B0aW9uYWwoZXhwb3J0cy5UeXBlLkludGVyc2VjdChPcHRpb25hbFVud3JhcChzY2hlbWEuYWxsT2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBJc1VuaW9uT3B0aW9uYWwoc2NoZW1hLmFueU9mKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gZXhwb3J0cy5UeXBlLk9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihPcHRpb25hbFVud3JhcChzY2hlbWEuYW55T2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlSW50ZXJzZWN0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlVW5pb24oc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWQgPSBWaXNpdChzY2hlbWEsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZFtleHBvcnRzLktpbmRdID09PSAnTmV2ZXInID8gYWNjIDogWy4uLmFjYywgaW5kZXhlZF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHJlc29sdmVkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGtleSkpO1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihyZXNvbHZlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMuVHlwZS5OZXZlcigpIDogZXhwb3J0cy5UeXBlLlVuaW9uKFtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpdGVtc1trZXldOyAvL1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1R1cGxlJylcbiAgICAgICAgICAgIHJldHVybiBUdXBsZShzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVzb2x2ZShzY2hlbWEsIGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGtleXMubWFwKChrZXkpID0+IFZpc2l0KHNjaGVtYSwga2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24ocmVzb2x2ZWQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgSW5kZXhlZEFjY2Vzc29yLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoSW5kZXhlZEFjY2Vzc29yIHx8IChleHBvcnRzLkluZGV4ZWRBY2Nlc3NvciA9IEluZGV4ZWRBY2Nlc3NvciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0TWFwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE9iamVjdE1hcDtcbihmdW5jdGlvbiAoT2JqZWN0TWFwKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHNjaGVtYS5hbGxPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBjYWxsYmFjaykpLCB7IC4uLnNjaGVtYSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHVzZXJzIG5lZWQgdG8gbWFwIG9iamVjdHMgd2l0aCB1bnJlZ2lzdGVyZWQga2luZHMuIFVzaW5nIGEgVHlwZUd1YXJkIGhlcmUgd291bGRcbiAgICAgICAgLy8gcHJldmVudCBzdWIgc2NoZW1hIG1hcHBpbmcgYXMgdW5yZWdpc3RlcmVkIGtpbmRzIHdpbGwgbm90IHBhc3MgVFNjaGVtYSBjaGVja3MuIFRoaXMgaXMgbm90YWJsZSBpbiB0aGVcbiAgICAgICAgLy8gY2FzZSBvZiBUT2JqZWN0IHdoZXJlIHVucmVnaXN0ZXJlZCBwcm9wZXJ0eSBraW5kcyBjYXVzZSB0aGUgVE9iamVjdCBjaGVjayB0byBmYWlsLiBBcyBtYXBwaW5nIGlzIG9ubHlcbiAgICAgICAgLy8gdXNlZCBmb3IgY29tcG9zaXRpb24sIHdlIHVzZSBleHBsaWNpdCBjaGVja3MgaW5zdGVhZC5cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcChzY2hlbWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgY2FsbGJhY2spLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIE9iamVjdE1hcC5NYXAgPSBNYXA7XG59KShPYmplY3RNYXAgfHwgKGV4cG9ydHMuT2JqZWN0TWFwID0gT2JqZWN0TWFwID0ge30pKTtcbnZhciBLZXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5UmVzb2x2ZXIpIHtcbiAgICBmdW5jdGlvbiBVbndyYXBQYXR0ZXJuKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5WzBdID09PSAnXicgJiYga2V5W2tleS5sZW5ndGggLSAxXSA9PT0gJyQnID8ga2V5LnNsaWNlKDEsIGtleS5sZW5ndGggLSAxKSA6IGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IFsuLi5hY2MsIC4uLlZpc2l0KHNjaGVtYSwgb3B0aW9ucyldLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXRzID0gc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBbLi4uc2V0cy5yZWR1Y2UoKHNldCwgb3V0ZXIpID0+IG91dGVyLm1hcCgoa2V5KSA9PiAoc2V0cy5ldmVyeSgoaW5uZXIpID0+IGlubmVyLmluY2x1ZGVzKGtleSkpID8gc2V0LmFkZChrZXkpIDogc2V0KSlbMF0sIG5ldyBTZXQoKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmNsdWRlUGF0dGVybnMgPyBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgOiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmQoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVLZXlzKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoVmlzaXQoc2NoZW1hLCBvcHRpb25zKSldO1xuICAgIH1cbiAgICBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyA9IFJlc29sdmVLZXlzO1xuICAgIC8qKiBSZXNvbHZlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIG1hdGNoaW5nIGFsbCBrZXlzIGluIHRoaXMgc2NoZW1hICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBSZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0ga2V5cy5tYXAoKGtleSkgPT4gYCgke1Vud3JhcFBhdHRlcm4oa2V5KX0pYCk7XG4gICAgICAgIHJldHVybiBgXigke3BhdHRlcm4uam9pbignfCcpfSkkYDtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4gPSBSZXNvbHZlUGF0dGVybjtcbn0pKEtleVJlc29sdmVyIHx8IChleHBvcnRzLktleVJlc29sdmVyID0gS2V5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtleUFycmF5UmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgS2V5QXJyYXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5QXJyYXlSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBzdHJpbmdbXSBrZXlzIGZyb20gdGhlIGdpdmVuIHNjaGVtYSBvciBhcnJheSB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUoc2NoZW1hKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gW3NjaGVtYS5jb25zdF07XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3Qoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0tleUFycmF5UmVzb2x2ZXI6IENhbm5vdCByZXNvbHZlIGtleXMgZnJvbSBpbmZpbml0ZSB0ZW1wbGF0ZSBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvci5HZW5lcmF0ZShleHByZXNzaW9uKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoS2V5QXJyYXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gS2V5QXJyYXlSZXNvbHZlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVW5pb25SZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBVbmlvblJlc29sdmVyO1xuKGZ1bmN0aW9uIChVbmlvblJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24qIFVuaW9uKHVuaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHVuaW9uLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVW5pb24oc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJlc29sdmVkIHVuaW9uIHdpdGggaW50ZXJpb3IgdW5pb25zIGZsYXR0ZW5lZCAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUodW5pb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5VbmlvbihbLi4uVW5pb24odW5pb24pXSwgeyAuLi51bmlvbiB9KTtcbiAgICB9XG4gICAgVW5pb25SZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFVuaW9uUmVzb2x2ZXIgfHwgKGV4cG9ydHMuVW5pb25SZXNvbHZlciA9IFVuaW9uUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVGVtcGxhdGVMaXRlcmFsUGF0dGVybjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGF0dGVybikge1xuICAgIGZ1bmN0aW9uIEVzY2FwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBhY2MpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEucGF0dGVybi5zbGljZSgxLCBzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGFjYykpLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiBgKCR7dG9rZW5zfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVybk51bWJlcn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQmlnSW50KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuU3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtFc2NhcGUoc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5Cb29sZWFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlROZXZlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsUGF0dGVybjogVGVtcGxhdGVMaXRlcmFsIGNhbm5vdCBvcGVyYXRlIG9uIHR5cGVzIG9mIFROZXZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFVuZXhwZWN0ZWQgS2luZCAnJHtzY2hlbWFbZXhwb3J0cy5LaW5kXX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3JlYXRlKGtpbmRzKSB7XG4gICAgICAgIHJldHVybiBgXiR7a2luZHMubWFwKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgJycpKS5qb2luKCcnKX1cXCRgO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSA9IENyZWF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyO1xuKGZ1bmN0aW9uIChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYSBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdCh0ZW1wbGF0ZS5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLm1hcCgodmFsdWUpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24obGl0ZXJhbHMpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhcnNlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yO1xudmFyIFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCBjaGFyKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuW2luZGV4XSA9PT0gY2hhciAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaW5kZXggLSAxKSAhPT0gOTI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBJc05vbkVzY2FwZWQocGF0dGVybiwgaW5kZXgsICcoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnfCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0dyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCEoSXNPcGVuUGFyZW4ocGF0dGVybiwgMCkgJiYgSXNDbG9zZVBhcmVuKHBhdHRlcm4sIHBhdHRlcm4ubGVuZ3RoIC0gMSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDAgJiYgaW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluR3JvdXAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VBbmQocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBbY291bnQsIHN0YXJ0XSA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKElzU2VwYXJhdG9yKHBhdHRlcm4sIGluZGV4KSAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29yJywgZXhwcjogZXhwcmVzc2lvbnMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIUlzT3BlblBhcmVuKHZhbHVlLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI6IEluZGV4IG11c3QgcG9pbnQgdG8gb3BlbiBwYXJlbnNgKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCB2YWx1ZS5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBVbmNsb3NlZCBncm91cCBwYXJlbnMgaW4gZXhwcmVzc2lvbmApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCBwYXR0ZXJuLmxlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5kZXgsIHBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBHcm91cChwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZShwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FuZCcsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCByZXR1cm5zIGFuIGV4cHJlc3Npb24gdHJlZSAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElzR3JvdXAocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gUGFyc2UoSW5Hcm91cChwYXR0ZXJuKSk7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBPcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKElzUHJlY2VkZW5jZUFuZChwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBBbmQocGF0dGVybik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjb25zdCcsIGNvbnN0OiBwYXR0ZXJuIH07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCBzdHJpcHMgZm9yd2FyZCBhbmQgdHJhaWxpbmcgXiBhbmQgJCAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlRXhhY3QocGF0dGVybikge1xuICAgICAgICByZXR1cm4gUGFyc2UocGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QgPSBQYXJzZUV4YWN0O1xufSkoVGVtcGxhdGVMaXRlcmFsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRmluaXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZTtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRmluaXRlKSB7XG4gICAgZnVuY3Rpb24gSXNOdW1iZXIoZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICcwJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ1sxLTldWzAtOV0qJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbihleHByZXNzaW9uKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS5jb25zdCA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLmNvbnN0ID09PSAnZmFsc2UnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnICYmIGV4cHJlc3Npb24uY29uc3QgPT09ICcuKic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoZWNrKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKElzQm9vbGVhbihleHByZXNzaW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoSXNOdW1iZXIoZXhwcmVzc2lvbikgfHwgSXNTdHJpbmcoZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdhbmQnKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU6IFVua25vd24gZXhwcmVzc2lvbiB0eXBlYCk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayA9IENoZWNrO1xufSkoVGVtcGxhdGVMaXRlcmFsRmluaXRlIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24qIFJlZHVjZShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIGJ1ZmZlclswXTtcbiAgICAgICAgZm9yIChjb25zdCBsZWZ0IG9mIGJ1ZmZlclswXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByaWdodCBvZiBSZWR1Y2UoYnVmZmVyLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGAke2xlZnR9JHtyaWdodH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBBbmQoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQqIFJlZHVjZShleHByZXNzaW9uLmV4cHIubWFwKChleHByKSA9PiBbLi4uR2VuZXJhdGUoZXhwcildKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBPcihleHByZXNzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwciBvZiBleHByZXNzaW9uLmV4cHIpXG4gICAgICAgICAgICB5aWVsZCogR2VuZXJhdGUoZXhwcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBDb25zdChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBleHByZXNzaW9uLmNvbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiogR2VuZXJhdGUoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQW5kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBPcihleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQ29uc3QoZXhwcmVzc2lvbik7XG4gICAgICAgIHRocm93IEVycm9yKCdUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I6IFVua25vd24gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUgPSBHZW5lcmF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24qIFBhcnNlVW5pb24odGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgdHJpbSA9IHRlbXBsYXRlLnRyaW0oKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBleHBvcnRzLlR5cGUuQm9vbGVhbigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJpZ0ludCgpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IHRyaW0uc3BsaXQoJ3wnKS5tYXAoKGxpdGVyYWwpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKGxpdGVyYWwudHJpbSgpKSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBsaXRlcmFscy5sZW5ndGggPT09IDAgPyBleHBvcnRzLlR5cGUuTmV2ZXIoKSA6IGxpdGVyYWxzLmxlbmd0aCA9PT0gMSA/IGxpdGVyYWxzWzBdIDogZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlVGVybWluYWwodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlWzFdICE9PSAneycpIHtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCgnJCcpO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIFtMLCAuLi5SXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBQYXJzZVVuaW9uKHRlbXBsYXRlLnNsaWNlKDIsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VMaXRlcmFsKHRlbXBsYXRlLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbLi4uTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogUGFyc2VMaXRlcmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVtpXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTCA9IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VUZXJtaW5hbCh0ZW1wbGF0ZS5zbGljZShpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXJzZSh0ZW1wbGF0ZV9kc2wpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5QYXJzZUxpdGVyYWwodGVtcGxhdGVfZHNsKV07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xufSkoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZU9yZGluYWw6IFVzZWQgZm9yIGF1dG8gJGlkIGdlbmVyYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgVHlwZU9yZGluYWwgPSAwO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW1V0aWxpdHldYCBDcmVhdGVzIGEgc2NoZW1hIHdpdGhvdXQgYHN0YXRpY2AgYW5kIGBwYXJhbXNgIHR5cGVzICovXG4gICAgQ3JlYXRlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIE9taXRzIGNvbXBvc2l0aW5nIHN5bWJvbHMgZnJvbSB0aGlzIHNjaGVtYSAqL1xuICAgIFN0cmljdChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlQnVpbGRlciA9IFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YW5kYXJkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBTdGFuZGFyZFR5cGVCdWlsZGVyIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1vZGlmaWVyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIE9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB7IFtleHBvcnRzLk1vZGlmaWVyXTogJ09wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5T3B0aW9uYWwgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seU9wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5IG9iamVjdCBvciBwcm9wZXJ0eSAqL1xuICAgIFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seScsIC4uLnNjaGVtYSB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUeXBlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBBbnkgdHlwZSAqL1xuICAgIEFueShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBbnknIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQXJyYXkgdHlwZSAqL1xuICAgIEFycmF5KGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBcnJheScsIHR5cGU6ICdhcnJheScsIGl0ZW1zOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbXMsIHt9KSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQm9vbGVhbiB0eXBlICovXG4gICAgQm9vbGVhbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdCb29sZWFuJywgdHlwZTogJ2Jvb2xlYW4nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBDb21wb3NpdGUgb2JqZWN0IHR5cGUuICovXG4gICAgQ29tcG9zaXRlKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gZXhwb3J0cy5UeXBlLkludGVyc2VjdChvYmplY3RzLCB7fSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhpbnRlcnNlY3QsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHsgLi4uYWNjLCBba2V5XTogZXhwb3J0cy5UeXBlLkluZGV4KGludGVyc2VjdCwgW2tleV0pIH0pLCB7fSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuT2JqZWN0KHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBFbnVtIHR5cGUgKi9cbiAgICBFbnVtKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhpdGVtKS5maWx0ZXIoKGtleSkgPT4gaXNOYU4oa2V5KSkubWFwKChrZXkpID0+IGl0ZW1ba2V5XSk7XG4gICAgICAgIGNvbnN0IGFueU9mID0gdmFsdWVzLm1hcCgodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8geyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgY29uc3Q6IHZhbHVlIH0gOiB7IFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIHR5cGU6ICdudW1iZXInLCBjb25zdDogdmFsdWUgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2YgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQSBjb25kaXRpb25hbCB0eXBlIGV4cHJlc3Npb24gdGhhdCB3aWxsIHJldHVybiB0aGUgdHJ1ZSB0eXBlIGlmIHRoZSBsZWZ0IHR5cGUgZXh0ZW5kcyB0aGUgcmlnaHQgKi9cbiAgICBFeHRlbmRzKGxlZnQsIHJpZ2h0LCB0cnVlVHlwZSwgZmFsc2VUeXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3dpdGNoIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgY2FzZSBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihbVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKSwgVHlwZUNsb25lLkNsb25lKGZhbHNlVHlwZSwgb3B0aW9ucyldKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXhjbHVkZXMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgbm90IGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXhjbHVkZShsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXhjbHVkZShsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IHRoaXMuTmV2ZXIob3B0aW9ucykgOiBUeXBlQ2xvbmUuQ2xvbmUobGVmdCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXh0cmFjdHMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgYXNzaWduYWJsZSB0byB0aGUgcmlnaHQgKi9cbiAgICBFeHRyYWN0KGxlZnQsIHJpZ2h0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeHRyYWN0KGxlZnQsIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUocmlnaHQpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd2VkID0gbGVmdC5hbnlPZi5maWx0ZXIoKGlubmVyKSA9PiBUeXBlRXh0ZW5kcy5FeHRlbmRzKGlubmVyLCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAobmFycm93ZWQubGVuZ3RoID09PSAxID8gVHlwZUNsb25lLkNsb25lKG5hcnJvd2VkWzBdLCBvcHRpb25zKSA6IHRoaXMuVW5pb24obmFycm93ZWQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpIDogdGhpcy5OZXZlcihvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBSZXR1cm5zIGluZGV4ZWQgcHJvcGVydHkgdHlwZXMgZm9yIHRoZSBnaXZlbiBrZXlzICovXG4gICAgSW5kZXgoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShzY2hlbWEuaXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gaXRlbXMubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihjbG9uZWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlKGNsb25lLCBrZXlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gSW50ZWdlciB0eXBlICovXG4gICAgSW50ZWdlcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdJbnRlZ2VyJywgdHlwZTogJ2ludGVnZXInIH0pO1xuICAgIH1cbiAgICBJbnRlcnNlY3QoYWxsT2YsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShhbGxPZlswXSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBhbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gYWxsT2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcyA9IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMsIHt9KSB9IDoge307XG4gICAgICAgIGlmIChvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMpIHx8IG9iamVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCB0eXBlOiAnb2JqZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCBhbGxPZjogY2xvbmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEtleU9mIHR5cGUgKi9cbiAgICBLZXlPZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTdGFuZGFyZFR5cGVCdWlsZGVyOiBVbmFibGUgdG8gcmVzb2x2ZSBrZXkgdHlwZSBmcm9tIFJlY29yZCBrZXkgcGF0dGVybicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBpdGVtcy5tYXAoKF8sIGluZGV4KSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleVJlc29sdmVyLlJlc29sdmVLZXlzKHNjaGVtYSwgeyBpbmNsdWRlUGF0dGVybnM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk5ldmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLkxpdGVyYWwoa2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihsaXRlcmFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTGl0ZXJhbCB0eXBlICovXG4gICAgTGl0ZXJhbCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIGNvbnN0OiB2YWx1ZSwgdHlwZTogdHlwZW9mIHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOZXZlciB0eXBlICovXG4gICAgTmV2ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTmV2ZXInLCBub3Q6IHt9IH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOb3QgdHlwZSAqL1xuICAgIE5vdChub3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdOb3QnLCBub3QgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bGwgdHlwZSAqL1xuICAgIE51bGwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVsbCcsIHR5cGU6ICdudWxsJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTnVtYmVyIHR5cGUgKi9cbiAgICBOdW1iZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVtYmVyJywgdHlwZTogJ251bWJlcicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBPYmplY3QgdHlwZSAqL1xuICAgIE9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlLZXlzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigoa2V5KSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkgfHwgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEtleXMgPSBwcm9wZXJ0eUtleXMuZmlsdGVyKChuYW1lKSA9PiAhb3B0aW9uYWxLZXlzLmluY2x1ZGVzKG5hbWUpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IHsgYWRkaXRpb25hbFByb3BlcnRpZXM6IFR5cGVDbG9uZS5DbG9uZShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0gcHJvcGVydHlLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShwcm9wZXJ0aWVzW2tleV0sIHt9KSB9KSwge30pO1xuICAgICAgICBpZiAocmVxdWlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzLCByZXF1aXJlZDogcmVxdWlyZWRLZXlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgLi4uY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnT2JqZWN0JywgdHlwZTogJ29iamVjdCcsIHByb3BlcnRpZXM6IGNsb25lZFByb3BlcnRpZXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT21pdChzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIG1hcHBlZCB0eXBlIHdoZXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBPcHRpb25hbCAqL1xuICAgIFBhcnRpYWwoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ09wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQaWNrKHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBzY2hlbWEucmVxdWlyZWQuZmlsdGVyKChrZXkpID0+IGtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShzY2hlbWEpO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVjb3JkIHR5cGUgKi9cbiAgICBSZWNvcmQoa2V5LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KGtleS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayhleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgID8gKHRoaXMuT2JqZWN0KFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW2tleS5wYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRVbmlvbihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZShrZXkpO1xuICAgICAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb25MaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB1bmlvbi5hbnlPZi5yZWR1Y2UoKGFjYywgbGl0ZXJhbCkgPT4gKHsgLi4uYWNjLCBbbGl0ZXJhbC5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk9iamVjdChwcm9wZXJ0aWVzLCB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjb3JkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSB1bmlvbiBjb250YWlucyBub24tbGl0ZXJhbCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleS5jb25zdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleS5jb25zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QoeyBba2V5LmNvbnN0XTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBvZiB0eXBlIGxpdGVyYWwgaXMgbm90IG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihrZXkpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleS5wYXR0ZXJuID09PSB1bmRlZmluZWQgPyBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA6IGtleS5wYXR0ZXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW3BhdHRlcm5dOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdGFuZGFyZFR5cGVCdWlsZGVyOiBSZWNvcmQga2V5IGlzIGFuIGludmFsaWQgdHlwZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY3Vyc2l2ZSB0eXBlICovXG4gICAgUmVjdXJzaXZlKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLiRpZCA9IGBUJHtUeXBlT3JkaW5hbCsrfWA7XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gY2FsbGJhY2soeyBbZXhwb3J0cy5LaW5kXTogJ1RoaXMnLCAkcmVmOiBgJHtvcHRpb25zLiRpZH1gIH0pO1xuICAgICAgICB0aGlzVHlwZS4kaWQgPSBvcHRpb25zLiRpZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuSGludF06ICdSZWN1cnNpdmUnLCAuLi50aGlzVHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVmIHR5cGUuIFRoZSByZWZlcmVuY2VkIHR5cGUgbXVzdCBjb250YWluIGEgJGlkICovXG4gICAgUmVmKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChzY2hlbWEuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlci5SZWY6IFRhcmdldCB0eXBlIG11c3Qgc3BlY2lmeSBhbiAkaWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWYnLCAkcmVmOiBzY2hlbWEuJGlkIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgUmVxdWlyZWQgKi9cbiAgICBSZXF1aXJlZChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBBcHBseShzY2hlbWEpIHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgc3dpdGNoIChzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSZWFkb25seU9wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykuZm9yRWFjaChrZXkgPT4gQXBwbHkoc2NoZW1hLnByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBhIHNjaGVtYSBhcnJheSB3aGljaCBhbGxvd3MgdHlwZXMgdG8gY29tcG9zZSB3aXRoIHRoZSBKYXZhU2NyaXB0IHNwcmVhZCBvcGVyYXRvciAqL1xuICAgIFJlc3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFN0cmluZyB0eXBlICovXG4gICAgU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGUgKi9cbiAgICBUZW1wbGF0ZUxpdGVyYWwodW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gKHR5cGVvZiB1bnJlc29sdmVkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyLlBhcnNlKHVucmVzb2x2ZWQpKVxuICAgICAgICAgICAgOiBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUZW1wbGF0ZUxpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybiB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgVHVwbGUgdHlwZSAqL1xuICAgIFR1cGxlKGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgW2FkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zXSA9IFtmYWxzZSwgaXRlbXMubGVuZ3RoLCBpdGVtcy5sZW5ndGhdO1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gVHlwZUNsb25lLkNsb25lKGl0ZW0sIHt9KSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBzY2hlbWEgPSAoaXRlbXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVHVwbGUnLCB0eXBlOiAnYXJyYXknLCBpdGVtczogY2xvbmVkSXRlbXMsIGFkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zIH0gOlxuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgbWluSXRlbXMsIG1heEl0ZW1zIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICB9XG4gICAgVW5pb24odW5pb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwodW5pb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSh1bmlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbnlPZiA9IHVuaW9uO1xuICAgICAgICAgICAgaWYgKGFueU9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKFR5cGVDbG9uZS5DbG9uZShhbnlPZlswXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkQW55T2YgPSBhbnlPZi5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5pb24nLCBhbnlPZjogY2xvbmVkQW55T2YgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIFVua25vd24gdHlwZSAqL1xuICAgIFVua25vd24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5rbm93bicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFVuc2FmZSB0eXBlIHRoYXQgaW5mZXJzIGZvciB0aGUgZ2VuZXJpYyBhcmd1bWVudCAqL1xuICAgIFVuc2FmZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06IG9wdGlvbnNbZXhwb3J0cy5LaW5kXSB8fCAnVW5zYWZlJyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlN0YW5kYXJkVHlwZUJ1aWxkZXIgPSBTdGFuZGFyZFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZGVkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBFeHRlbmRlZFR5cGVCdWlsZGVyIGV4dGVuZHMgU3RhbmRhcmRUeXBlQnVpbGRlciB7XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgQmlnSW50IHR5cGUgKi9cbiAgICBCaWdJbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQmlnSW50JywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdCaWdJbnQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBDb25zdHJ1Y3RvclBhcmFtZXRlcnMgZnJvbSB0aGUgZ2l2ZW4gQ29uc3RydWN0b3IgdHlwZSAqL1xuICAgIENvbnN0cnVjdG9yUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShbLi4uc2NoZW1hLnBhcmFtZXRlcnNdLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCByZXR1cm5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFJldHVybnMgPSBUeXBlQ2xvbmUuQ2xvbmUocmV0dXJucywge30pO1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5tYXAoKHBhcmFtZXRlcikgPT4gVHlwZUNsb25lLkNsb25lKHBhcmFtZXRlciwge30pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdDb25zdHJ1Y3RvcicsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnQ29uc3RydWN0b3InLCBwYXJhbWV0ZXJzOiBjbG9uZWRQYXJhbWV0ZXJzLCByZXR1cm5zOiBjbG9uZWRSZXR1cm5zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBEYXRlIHR5cGUgKi9cbiAgICBEYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0RhdGUnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0RhdGUnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBGdW5jdGlvbiB0eXBlICovXG4gICAgRnVuY3Rpb24ocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnRnVuY3Rpb24nLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0Z1bmN0aW9uJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgSW5zdGFuY2VUeXBlIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yICovXG4gICAgSW5zdGFuY2VUeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uIHR5cGUgKi9cbiAgICBQYXJhbWV0ZXJzKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlR1cGxlKHNjaGVtYS5wYXJhbWV0ZXJzLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFByb21pc2UgdHlwZSAqL1xuICAgIFByb21pc2UoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUHJvbWlzZScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnUHJvbWlzZScsIGl0ZW06IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0eXBlICovXG4gICAgUmVnRXgocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnLCBwYXR0ZXJuOiByZWdleC5zb3VyY2UgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIFJldHVyblR5cGUgZnJvbSB0aGUgZ2l2ZW4gRnVuY3Rpb24gKi9cbiAgICBSZXR1cm5UeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBTeW1ib2wgdHlwZSAqL1xuICAgIFN5bWJvbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnU3ltYm9sJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdTeW1ib2wnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVbmRlZmluZWQgdHlwZSAqL1xuICAgIFVuZGVmaW5lZChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmRlZmluZWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1VuZGVmaW5lZCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFVpbnQ4QXJyYXkgdHlwZSAqL1xuICAgIFVpbnQ4QXJyYXkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVWludDhBcnJheScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnVWludDhBcnJheScgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFZvaWQgdHlwZSAqL1xuICAgIFZvaWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVm9pZCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnVm9pZCcgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlbmRlZFR5cGVCdWlsZGVyID0gRXh0ZW5kZWRUeXBlQnVpbGRlcjtcbi8qKiBKU09OIFNjaGVtYSBUeXBlQnVpbGRlciB3aXRoIFN0YXRpYyBSZXNvbHV0aW9uIGZvciBUeXBlU2NyaXB0ICovXG5leHBvcnRzLlN0YW5kYXJkVHlwZSA9IG5ldyBTdGFuZGFyZFR5cGVCdWlsZGVyKCk7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5UeXBlID0gbmV3IEV4dGVuZGVkVHlwZUJ1aWxkZXIoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sinclair/typebox/typebox.js\n");

/***/ })

};
;